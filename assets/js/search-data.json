{
  
    
        "post0": {
            "title": "Deel 2 - Een Flutter App - Voorbereiden App Structuur",
            "content": "Hallo allemaal! . Leuk dat jullie hier weer zijn om dit project te volgen. In deze post neem ik jullie mee in de planning voor de codestructuur van de app die ik aan het maken ben. Omdat dit mijn eerste eigen Flutter project is, neem ik veel informatie over van andere bronnen. Hierdoor leer je op een andere manier (dan je automatische piloot) kijken naar het opzetten van projecten. En wanneer dit bevalt kan je dat uiteraard inbouwen in je automatische werkwijze voor je volgende projecten! . Stappenplan App maken . In de vorige post van dit project1 heb ik de vereisten vastgesteld. In die fase beschreef ik wat de app moet hebben om de klant haar problemen op te lossen. Maar op technisch vlak is dan nog niets bepaald. Deze fase gaat over het technische vlak, namelijk wat zijn de technische stappen die nodig zijn om de app op te leveren. Voor dit project heb ik grofweg de App Development Workflow van Code with Andrea2 aangehouden. . Over de eerste twee stappen, Design en Database/Backend, kan ik kort zijn. Het Design zal een simpele lijstweergave zijn (de standaard ingebouwd in Flutter). En voor versie 1 (V1) hebben we gezegd: hardcoded practices (dus geen database) en er is ook geen backend nodig. Dat waren de eerste twee stappen al, maar de volgende stap is een stuk uitdagender! . De derde stap is namelijk het bepalen van de app architectuur. Nu is dit dus mijn eerste Flutter project en heb ik nog geen goed idee over wat de handigste app structuur voor een Flutter project is. Gelukkig werk ik ondertussen wel aan een andere Flutter app waarin we Flutter Blocs gebruiken. En in de voorbeelden van Flutter Blocs kwam ik een structuur tegen die mij aansprak3. Hieronder heb ik diezelfde structuur vertaald naar de app die ik aan het maken ben. . . Opmerking:Onderstaande alinea&#39;s zijn technisch, maar daar ontkom je niet aan bij het bepalen van de app architectuur :). . De Data Layer is, zoals de naam van de layer ook omschrijft, de connectie naar je onbewerkte data. Deze wil je het liefste zo generiek mogelijk houden en is vaak een simpele API om CRUD (Create, Read, Update, Delete) operaties uit te voeren. In de app Data Layer zitten twee componenten, de Daily Practices API en Hardcoded Daily Practices API. De eerstgenoemde is de generieke interface (een soort van blauwdruk van je verschillende implementaties). Als V1 heb ik vastgesteld dat de Daily Practices hardcoded en niet aanpasbaar zijn. Daarom hebben deze APIs voor V1 alleen een leesoperatie nodig. De specifieke implementatie hiervan wordt gedaan in de Hardcoded Daily Practices API. . De volgende laag is de Domain Layer. Hierin koppel je de data APIs in een repository. Je voegt hieraan zogeheten business rules toe om bijvoorbeeld data te filteren of in een bepaalde structuur door te geven aan je Blocs in de feature layer. . De repository layer geeft de data dus door aan je Blocs in de Feature Layer. Hierdoor fungeert je Bloc als brug tussen de data en de (User Interface) UI in je app. De Bloc bevat je business (b) logic (loc). Afhankelijk van acties van de gebruiker vraagt de Bloc data op uit (mogelijk verschillende) repositories. Hierdoor verandert de state van je Bloc. Deze verandering wordt opgepikt door de UI en daardoor past de UI van de app zich aan. Het grootste voordeel van deze structuur is dat de business logic en UI gescheiden zijn. Dit reduceert coupling en daardoor zijn de afzonderlijke onderdelen van je app in isolatie te testen en te gebruiken! . Nadat de app architectuur is bepaald, kan je samen met de vereisten een project board maken. In eerste instantie gebruikte ik Trello maar later dacht ik dat het handiger zou zijn om alles op 1 plek te hebben. Daarom ben ik overgestapt naar Github Projects4. Ik heb geprobeerd om het zo volledig mogelijk te maken, maar het zal vast zijn dat ik zaken ben vergeten. Dus dat vul ik in wanneer ik dat tegenkom. Het project board heb ik opgedeeld in verschillende onderwerpen (Test, UI, Flutter en CI/CD). En daaronder heb ik dan de verschillende taken bedacht en aangemaakt. Toen dat gedaan was kon ik beginnen aan de volgende stap, de CI/CD pipeline. . Door te beginnen met de CI/CD pipeline kan je zo vroeg mogelijk beginnen met testen. Omdat alles op Github staat gebruiken we in dit geval Github Actions voor onze (in eerste instantie niet CD) CI pipeline. De specifieke implementatie van de Github Actions zal ik in een volgende post vertellen. . De laatste stap is het uitvoeren van de taken op je project board! Ondertussen ben ik al begonnen. Doordat ik bij mijn vorige projecten een andere werkwijze aanhield, was even wennen. Maar eenmaal in het ritme gekomen ging alles voortvarend! Ik heb veel geleerd en veel van de taken zijn voltooid. Op dit moment ben ik vastgelopen op het notificatie deel maar wanneer dat werkt is V1 zo goed als af! Hopelijk lukt dat binnenkort! . Tot de volgende keer :) . Mees . 1. Android App in Flutter Deel 1 - Voorbereiding↩ . 2. Code With Andrea App Development Worklfow↩ . 3. Bloclibrary - Flutter Todos Tutorial↩ . 4. Github Project Board - Flutter App↩ .",
            "url": "https://cabbagemees.nl/flutter/android/devops/2022/07/26/Flutter-app-deel-2-app-architectuur.html",
            "relUrl": "/flutter/android/devops/2022/07/26/Flutter-app-deel-2-app-architectuur.html",
            "date": " • Jul 26, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Tussenproject - Tour de France",
            "content": "Het jaarlijkse wielerspektakel de Tour de France staat weer voor de deur! Dat betekent ook dat ik renners mag gaan kiezen voor de eveneens jaarlijks terugkerende Wielerpoule (in het kort, je kiest een aantal wielrenners die mee gaan doen met de Tour en op basis van hun uitslag haal je punten). Nu heb ik de laatste jaren het wielrennen niet tot nauwelijks gevolgd waardoor ik geen idee heb welke renners er in vorm zijn. Daarom heb ik weer besloten om mijn programmeer en machine learning (ML) vaardigheden te gebruiken. Hiermee hoop ik het beste team samen te stellen. Als eerste hebben we data nodig om de beste renners te kunnen voorspellen en gelukkig is er een mooie website waar wij die data vanaf kunnen halen! . Data van een website halen . Om met Python data van een website te halen heb je verschillende Python packages ter beschikking. Een van deze packages heb ik al vaker gebruikt en voor dit project ga ik dat weer gebruiken, BeautifulSoup (BS). Met BS kan je makkelijk navigeren door de HTML (opmaak) van een website en daarvandaan dan ook tekst ophalen. Maar dan moet je wel een website kunnen opvragen met coderen! Gelukkig kan dit ook met Python, namelijk met de requests package. In onderstaande code zie je een voorbeeld van hoe je een website in een BS object laad (zie hieronder). . race_url = r&quot;https://www.procyclingstats.com/race/tour-de-france/2022/stage-4&quot; # Perform a get request on the url req = requests.get(race_url) # Make a BeautifulSoup object from the requests&#39;s text soup = BeautifulSoup(req.text, &quot;lxml&quot;) # Get the title of the page print(soup.find(&#39;title&#39;).string) . Tour de France 2022 Stage 4 results . Vervolgens kan je ingebouwde methodes van het BS object gebruiken om door de HTML te zoeken. Zelf kijk ik eerst in de internet browser naar de elementen van de website waarvan ik de data wil. Afhankelijk van de browser die je gebruikt kan je elementen inspecteren. Ik let daarbij op het het HTML type (div, table, etc) en of het een class of id heeft. Met deze informatie kan je dan een specifiek element zoeken, zoals de top-20 van een uitslag (zie hieronder). . race_url = r&quot;https://www.procyclingstats.com/race/tour-de-france/2022/stage-4&quot; # Perform a get request on the url req = requests.get(race_url) # Make a BeautifulSoup object from the requests&#39;s text soup = BeautifulSoup(req.text, &quot;lxml&quot;) # I used the browser to find the element we are interested in result_list = soup.find(&quot;table&quot;, class_=&quot;results basic moblist10&quot;).find(&quot;tbody&quot;) # Each result is in a table row (tr) results = result_list.find_all(&quot;tr&quot;) race_top_20 = {} for i in range(20): result = results[i] # Again, use your browser to find the element you are interested in rider = result.find_all(&quot;a&quot;)[0].text race_top_20[i + 1] = rider pprint.pprint(race_top_20) . {1: &#39;VAN AERT Wout&#39;, 2: &#39;PHILIPSEN Jasper&#39;, 3: &#39;LAPORTE Christophe&#39;, 4: &#39;KRISTOFF Alexander&#39;, 5: &#39;SAGAN Peter&#39;, 6: &#39;MOZZATO Luca&#39;, 7: &#39;VAN POPPEL Danny&#39;, 8: &#39;HOFSTETTER Hugo&#39;, 9: &#39;MATTHEWS Michael&#39;, 10: &#39;THOMAS Benjamin&#39;, 11: &#39;DAINESE Alberto&#39;, 12: &#39;PEDERSEN Mads&#39;, 13: &#39;JAKOBSEN Fabio&#39;, 14: &#39;PASQUALON Andrea&#39;, 15: &#39;WRIGHT Fred&#39;, 16: &#39;NAESEN Oliver&#39;, 17: &#39;NEILANDS Krists&#39;, 18: &#39;KRIEGER Alexander&#39;, 19: &#39;BISSEGGER Stefan&#39;, 20: &#39;VLASOV Aleksandr&#39;} . De opgehaalde data . In totaal had ik deze data opgehaald: . Van de Tour de France van 2000 - 2021 alle renners die mee deden | Via al die renners, voor ieder jaar, de races en eindklassering URLs | Voor alle renners de geboortedatum, de teams en de PCS score (de laatste twee voor ieder jaar) | Voor iedere race de datum, top-20 en de gemiddelde PCS score van de top-20 | . Nadat al deze data is verzameld kunnen we deze data gebruiken om de features te gaan maken waarmee je een ML model kunt trainen. . Features maken . Een feature is een deel van de totale informatie waarmee je een voorspelling kunt maken. Bijvoorbeeld, wanneer je iemands gewicht wilt voorspellen aan de hand van iemands lengte, dan is lengte je feature (zie grafiek hieronder). Hoewel het verband tussen gewicht en lengte niet 1 op 1 is zijn over het algemeen lange mensen zwaarder dan kleine mensen. Een andere feature die je dan zou kunnen toevoegen om je voorspelling te verbeteren is bijvoorbeeld het aantal uren sporten per week. Samen met de lengte zal dit betere voorspellingen geven omdat (vaak) wanneer je meer sport je geen uitschieter hebt in gewicht (een nogal grove aanname). Zoals je misschien merkt kan je vele features bedenken en daarom heb je zeker een mate van creativiteit nodig! . . . data van:https://www.tno.nl/groei . Twee jaar geleden (v1) had ik ook een ML model gemaakt maar dit keer wilde ik nieuwe features gebruiken. In V1 had ik het idee om de races op te delen in types (vlak, heuvelachtig met vlakke finish, heuvelachtig met finish bergop, gebergte met vlakke finish en gebergte met finish bergop; Voor de races waar dit niet voor bekend was had ik zelfs een model getraind om dat te voorspellen). Vervolgens had ik voor iedere types de plekken 1 t/m 4, 5 t/m 8 en 9 t/m 12 ingedeeld (zie Tabel hieronder). Voor iedere renner telde ik dan in het voorgaande jaar hoe vaak iemand deze uitslag in deze type had (zie voorbeeld van Chris Froome hieronder). Hoewel ik best tevreden was met deze features, namen ze niet mee hoe sterk het deelnemersveld was. Wanneer je veel wint maar je tegenstand niet heel sterk is, is deze overwinning minder relevant (weer een grove aanname) in de Tour, want in de Tour is het deelnemersveld vaak erg sterk. Daarom heb ik voor deze Tour de France nieuwe features bedacht. . Features Chris Froome . PCS | 1377 | . Team PCS | 4172 | . Age | 29 | . flat1-4 | 1.0 | . flat5-8 | 0.0 | . flat9-12 | 2.0 | . hills(flat)1-4 | 1.0 | . hills(flat)5-8 | 0.0 | . hills(flat)9-12 | 1.0 | . hills(uphill)1-4 | 2.0 | . hills(uphill)5-8 | 1.0 | . hills(uphill)9-12 | 1.0 | . mountains(flat)1-4 | 1.0 | . mountains(flat)5-8 | 0.0 | . mountains(flat)9-12 | 1.0 | . mountains(uphill)1-4 | 4.0 | . mountains(uphill)5-8 | 5.0 | . mountains(uphill)9-12 | 1.0 | . gc1-4 | 3.0 | . gc5-8 | 1.0 | . gc9-12 | 1.0 | . Voor deze Tour nemen we bij iedere rit dus de sterkte van het deelnemersveld mee. Dat doen we door de gemiddelde PCS score van de top-20 uit te rekenen. Vervolgens verdelen we de ritten in 5 kwantielen (zeer weinig competitief, weinig competitief, competitief, erg competitief en zeer erg competitief). En daarbij had ik dan dit keer de resultaten als volgt verdeeld: 1 t/m 5, 6 t/m 10, 11 t/m 15 en 16 t/m 20 (zie tabel met voorbeeld van Wout van Aert hieronder). . Features Wout van Aert . PCS | 2820 | . Team PCS | 9724 | . PCS ratio | 0.29 | . Age | 27 | . top_5s_category_0 | 0 | . top_10s_category_0 | 0 | . top_15s_category_0 | 0 | . top_20s_category_0 | 0 | . top_5s_category_1 | 0 | . top_10s_category_1 | 0.0 | . top_15s_category_1 | 0 | . top_20s_category_1 | 0 | . top_5s_category_2 | 2 | . top_10s_category_2 | 0 | . top_15s_category_2 | 0 | . top_20s_category_2 | 0 | . top_5s_category_3 | 1 | . top_10s_category_3 | 1 | . top_15s_category_3 | 0 | . top_20s_category_3 | 0 | . top_5s_category_4 | 11 | . top_10s_category_4 | 2 | . top_15s_category_4 | 2 | . top_20s_category_4 | 0 | . top_5s_category_gc | 1.0 | . top_10s_category_gc | 0.0 | . top_15s_category_gc | 0 | . top_20s_category_gc | 0 | . Daarnaast had ik nog een aantal renner specifieke features: leeftijd, PCS score, PCS punten van het team en PCS ratio (eigen PCS / team PCS). Nu hebben we alle features waarop we een ML model kunnen trainen! . Het trainen van een model . Voor data, zoals in dit project, in een tabel structuur is het meest gebruikte en vaak ook beste model een vorm van een gradient boosted tree. In het kort is een tree vaak verdeeld in een aantal ja/nee vragen. Een voorbeeld van een simpele tree is een decision tree (voorbeeld hieronder). Het idee van deze tree is in de loop van de tijd al meer uitgebreid, van random forests naar dus gradient boosted trees. Dit zijn (simpel en kort door de bocht) een verzameling van meerdere trees die na het trainen heel goed zijn om een voorspelling te maken. Een van mijn favoriete tree algoritmes is XGBoost en deze gaan we dan ook gebruiken! . . Een XGBoost model is redelijk makkelijk te trainen door (jawel alweer!) een Python package: XGBoost. Alhoewel, je hebt dan nog heel veel instellingen die kunt optimaliseren. Gelukkig heb je daar ook een goede bron voor, namelijk Gridsearch van Sklearn (alweer een package!). Wanneer je Gridsearch en XGBoost combineert kan je meerdere instellingen vergelijken en dan krijg je als resultaat de getrainde modellen (met de verschillende parameters). Je kunt dan zelfs het beste model met de beste instellingen opvragen! Ideaal en het voelt als magie! . De resultaten . De resultaten van het model zien er op het eerste gezicht niet raar uit (zie hieronder). De volgens Wielerpoule duurste renners zitten qua voorspelling bovenin. Met voor mij als opvallendste naam Vlasov (voor mij geen bekende naam maar de laatste tijd volg ik het wielrennen nauwelijks). Om mijn team samen te stellen heb ik de voorspelde punten gedeeld door de kosten. En daar heb ik, naast de top 4, mijn team mee opgevuld. Eens zien of we mee gaan spelen voor de prijzen! . rider_name prediction price score_price_ratio . | VAN DER POEL Mathieu | 84.196594 | 200 | 0.420983 | . | VLASOV Aleksandr | 75.061699 | 150 | 0.500411 | . | POGACAR Tadej | 70.501328 | 200 | 0.352507 | . | ROGLIC Primož | 67.192093 | 200 | 0.335960 | . | VAN AERT Wout | 66.121864 | 200 | 0.330609 | . | MARTINEZ Daniel Felipe | 58.990757 | 100 | 0.589908 | . | VINGEGAARD Jonas | 57.898109 | 150 | 0.385987 | . | JAKOBSEN Fabio | 55.955868 | 150 | 0.373039 | . | KUNG Stefan | 55.773567 | 100 | 0.557736 | . | KRISTOFF Alexander | 54.939995 | 100 | 0.549400 | . | COSNEFROY Benoit | 54.132721 | 100 | 0.541327 | . | PEDERSEN Mads | 50.576691 | 100 | 0.505767 | . | MOHORIC Matej | 50.398064 | 100 | 0.503981 | . | VAN BAARLE Dylan | 49.590599 | 100 | 0.495906 | . | HOFSTETTER Hugo | 49.079250 | 100 | 0.490793 | . | EWAN Caleb | 46.512360 | 100 | 0.465124 | . | LAPORTE Christophe | 44.920681 | 100 | 0.449207 | . | TEUNS Dylan | 44.595673 | 100 | 0.445957 | . | MCNULTY Brandon | 44.574734 | 100 | 0.445747 | . | PHILIPSEN Jasper | 44.041866 | 100 | 0.440419 | . Tot de volgende keer en veel plezier met het volgen van de Tour de France! . Mees . P.S: De uiteindelijke dataset samen met de code voor het trainen van het ML model kan je vinden in deze Github repo. . P.S 2: Tot dusver werkt het model (na ongeveer 1 week) redelijk. Helaas valt Mathieu van der Poel tegen (en die was het duurste). .",
            "url": "https://cabbagemees.nl/python/tussenproject/ai/ml/2022/07/13/Tussenproject-Tour-De-France-Poule-Voorspellen.html",
            "relUrl": "/python/tussenproject/ai/ml/2022/07/13/Tussenproject-Tour-De-France-Poule-Voorspellen.html",
            "date": " • Jul 13, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Android App in Flutter Deel 1 - Voorbereiding",
            "content": "In deze post neem ik jullie mee met de voorbereidingen van het maken van een Android app. Nu zie ik de vraagtekens in je hersenspinsels verschijnen, want je hebt gelijk: een Android app kan van alles zijn. Daarom is de eerste stap bij het maken van een stuk software, zoals een app, belangrijk om te bepalen wat de gebruiker (of klant) wilt. Specifieker nog: welk probleem wil de gebruiker verholpen zien worden? . In een team op de werkvloer wordt deze vraag vaak in kaart gebracht door de product owner. Als product owner werk je naar een bepaald doel (bijvoorbeeld 10% meer omzet) van het bedrijf en dit doe je door je software te maken naar de wensen van je (potentiële) gebruikers. Vervolgens zet je deze wensen om in software features (of user stories) en splits je deze op in kleine taken. Daarna buigt het development team zich erover om de technische kant vorm te geven en weer te verdelen in taken. Deze taken worden op een sprint (vaak een periode van 1 - 4 weken) gezet om af te ronden. Door dit proces blijf je altijd werken aan taken die er toe doen voor de klant. . Aanvulling: Tegenwoordig is er wel eens kritiek op bovenstaande aanpak en zou het beter kunnen zijn om het development team zelf de wensen van klanten in kaart te laten brengen. Hierdoor kan het development team rechtstreeks de klant helpen in plaats van te communiceren met een tussenpersoon. . Het makkelijke aan een eigen project is dat je zelf de klant bent. In dit geval heb ik een probleem en deze wil ik oplossen. Daardoor is het relatief eenvoudig om het probleem vast te stellen, namelijk: er is geen makkelijk te gebruiken Android app om een lijst van taken aan te maken en van deze lijst iedere ochtend 1 willekeurige taak als notificatie binnen te krijgen. (misschien bestaat zo een app wél al, maar ik wil ook graag leren hoe je aan app maakt! :)). Nu dit probleem duidelijk is kan de product owner (wederom ikzelf, ik heb nog niemand aan kunnen nemen door de krapte op de arbeidsmarkt) aan de user stories beginnen. . Wanneer je begint aan het maken van de user stories is het belangrijk om niet te gedetailleerd te zijn. Het is vaak handiger om een ruwe prototype te maken (ook wel een minimal viable product (MVP) genoemd). Hiermee kan je snel vaststellen of je de capaciteiten in het team hebt om het product te maken. Maar misschien nog belangrijker, je kunt snel feedback vragen aan de gebruiker zodat je kan testen of de user stories daadwerkelijk het probleem van de gebruiker oplossen. Of dat er misschien onduidelijkheden waren waardoor de user stories niet 100% aansloten maar dat je nu nog op tijd bent om de software aan te passen. Voor mij is dat ook het doel, om met een MVP bovenstaand probleem op te lossen. . De MVP . Wanneer je begint aan het maken van de user stories is het belangrijk om niet te gedetailleerd te zijn. Het is vaak handiger om een ruwe prototype te maken (ook wel een minimal viable product (MVP) genoemd). Hiermee kan je snel vaststellen of je de capaciteiten in het team hebt om het product te maken. Maar misschien nog belangrijker, je kunt snel feedback vragen aan de gebruiker zodat je kan testen of de user stories daadwerkelijk het probleem van de gebruiker oplossen. Of dat er misschien onduidelijkheden waren waardoor de user stories niet 100% aansloten maar dat je nu nog op tijd bent om de software aan te passen. Voor mij is dat ook het doel, om met een MVP bovenstaand probleem op te lossen. . MVP Volgende Versie . Lijst met hardcoded practices | Lijst dynamisch kunnen aanpassen en opslaan in een database | . 1 willekeurige practice van bovenstaande lijst pakken | Tijd van de notificatie en hoeveel notificaties aanpasbaar maken | . Bovenstaande practice als notificatie geven | Willekeur als optie kunnen aanvinken | . Niet 2x dezelfde notificatie achter elkaar | Practice voor de dag weergeven wanneer je de app opent | . Alles met unit en functionele tests | | . CI/CD pipeline | | . Versie controle (Git) | | . Deze vereisten worden dan door het technische team in taken verdeeld om dit technisch op te lossen. Het is dan fijn wanneer de taken zo klein mogelijk zijn, zodat je iedere dag werkende (en geteste) code kan toevoegen aan je project en je niet hoeft te werken in branches. Belangrijk hierbij is dat de taken zichtbaar zijn, zodat je (bijvoorbeeld) de volgende vragen kunt beantwoorden: Waar wordt aan gewerkt? Loopt er een taak vast? Dit zorgt er mede voor dat je de obstakels kunt oplossen of verbeteren, waardoor je in het vervolg soortgelijke taken sneller kan afronden en daarmee ook sneller de gebruiker (die vaak ongeduldig zijn) kan helpen! . De DevOps principes in dit project . Zoals in de vorige post uitgelegd wil ik mij met ieder project ook bezig houden met de DevOps principes (om daar beter in te worden). Nu voel ik mij niet geschikt om DevOps samen te vatten, maar toch probeer ik het: “DevOps is een werkwijze welke het doel heeft om zo snel en goed mogelijk problemen op te lossen van een gebruiker (met software)”. Een voorbeeld daarvan is de taken zichtbaar maken (zoals hierboven beschreven). Maar er zijn ook vele andere manieren om het DevOps doel te bereiken (daar zijn verschillende boeken over bijvoorbeeld Accelerate van Nicole Forsgen en The DevOps Handbook van Gene Kim). De manieren in dit project om op de DevOps manier te werken wil ik hier graag herhalen: . Vergaar en implementeer klant feedback: maak een MVP dat de klant zo snel mogelijk kan beoordelen en jij daardoor kan aanpassen. | Alles in versie controle (ook configuratie bestanden!) | CI/CD pipeline. Dat betekent in het kort: na iedere code incheck dat er automatisch testen worden uitgevoerd en wanneer deze testen succesvol zijn uitgevoerd dat deze nieuwe code automatisch in de live software komt. | Werk in kleine batches/taken opdelen. Het liefste in taken die maximaal in 1 dag af te ronden zijn. Hierdoor hoef je niet in branches te werken. | Maak je werk zichtbaar! Zelf gebruik ik nu een Trello board (dit ga ik misschien nog veranderen) waarin ik taken kan slepen van todo naar in progress en dan naar done. | . Er zijn nog veel meer principes, maar voor dit project focus ik mij op bovenstaande punten. . Voordat ik deze post afrond wil ik nog melden dat dit de eerste keer is dat ik een android app maak. Dat betekent dat ik op de afgelopen tijd vooral bezig was met het leren van Kotlin voor Android apps. Hiermee ben ik nu klaar. Daarnaast ben ik ook bezig geweest met Flutter. Met Flutter kan je gemakkelijk multi-platform apps maken, wat het een interessante tool maakt. Daarom wil ik deze eerste app met Flutter schrijven om daar beter in te worden. . Tot de volgende keer! . Geniet van vandaag :) . Mees .",
            "url": "https://cabbagemees.nl/flutter/android/devops/2022/06/27/Flutter-app-deel-1-voorbereiding.html",
            "relUrl": "/flutter/android/devops/2022/06/27/Flutter-app-deel-1-voorbereiding.html",
            "date": " • Jun 27, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Een Nieuwe Stap",
            "content": "Een Tijdje Geleden . Het is alweer een tijdje geleden dat ik voor het laatste iets op de blog geschreven heb. Toen ik begon als Machine Learning (ML) Engineer was ik vooral daar mijn tijd aan kwijt, zodat ik mij zo goed mogelijk kon ontwikkelen en een mooi product kon maken. Ik denk dat ik mag zeggen dat beide zijn gelukt. Het gevolg daarvan is dat ik een volgende stap mag zetten naar een nieuwe werkgever waar ik ontzettend naar uit kijk! Voordat ik daar zou gaan beginnen hadden mijn vriendin en ik drie weken vakantie genomen, waarin we veel rust hebben gepakt. Ook heb ik kunnen nadenken over activiteiten naast werk, zoals deze blog. Hier had ik, toen ik begon, bepaalde ideeën over, maar deze zijn nu veranderd. In deze post wil ik dat toelichten en hopelijk lijkt het jullie interessant om met mij een nieuw avontuur te beleven. . Het Nieuwe Idee . Tijdens de vakantie heb ik een nieuw idee bedacht om het voor mezelf makkelijker te maken om meer te gaan bloggen, namelijk op projectbasis. Zelf programmeer ik namelijk ook in projecten en ik denk dat dit zal helpen met het schrijven van een blogpost. Daarbij komt ook dat het proces van een nieuw project niet vaak beschreven wordt (althans ik heb dit naast standaard tutorials niet veel gevonden). Wellicht is het voor anderen ook waardevol om via deze weg meer te leren over het maken van een nieuw project. . De Planning . Voor nu heb ik een voorlopige planning gemaakt maar deze staat zeker niet vast (Ik schrijf nu namelijk op de Note Air 2, en het zou super handig zijn wanneer handgeschreven notities automatisch worden omgezet naar een Jupyter Notebook. Aan dit project ben ik meteen begonnen wat de planning na 2 dagen al overhoop gooide :)). Maar toch probeer ik mij aan deze planning te houden: . Automatisch handgeschreven tekst naar Jupyter Notebook | Android app maken (Minimum Viable Product: MVP) | . | Functioneel programmeren Python module schrijven (op basis van het boek Grocking Simplicity) | Anki Add-on (MVP) | Recepten Web-App (MVP) | Daarna wordt het waarschijnlijk het verbeteren van de MVPs naar nieuwere versies. Maar zoals gezegd, bestaat er een kans op verschuivingen in de planning en tussenkomende projecten. . Proces . Ook wil ik zoveel mogelijk via DevOps (hierover later meer!) principes gaan werken om zo te laten zien hoe je in de praktijk (wat ik nu weet) zou kunnen werken. Zelf heb ik namelijk ondervonden dat dit nauwelijks wordt uitgelegd. Ik geloof dat werken met DevOps principes veel voordelen heeft maar dat ik mij hier nog veel in kan verbeteren. Daarom ga ik dat in eigen projecten toepassen en hoor ik ook graag wat jullie zouden doen! . Hopelijk geeft dit een duidelijk beeld en lijkt het jullie leuk om te volgen. Bedankt voor het lezen en hopelijk tot de volgende keer! . Fijne dag! . Mees .",
            "url": "https://cabbagemees.nl/de%20reis/2022/06/07/Een-nieuwe-stap.html",
            "relUrl": "/de%20reis/2022/06/07/Een-nieuwe-stap.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
  
    
        ,"post5": {
            "title": "Kwaadaardige moedervlekken herkennen met artificiële intelligentie",
            "content": "Hoi hoi, . Vandaag wil ik een voorbeeld delen van Artificiële Intelligentie (AI) in de biologie. Maar voordat ik begin, een kleine waarschuwing. In deze post komen mogelijk onbekende en moeilijke termen voor. Wanneer ik ze allemaal in deze post uit ga leggen wordt de post ietwat lang. Daarom heb ik soms een korte uitleg gegeven ,maar op andere momenten niet ,want het idee is om deze termen uitvoerig te bespreken in de volgende posts. Dat gezegd hebbende, deze post gaat over mijn eerste project dat ik gemaakt heb, namelijk een model (eigenlijk een soort van computerprogramma) dat kan voorspellen of een moedervlek goed- of kwaadaardig is 1. Hiermee was ik begonnen ,omdat de (gratis!) online cursus van Fastai 2 aanbeveelt om zo snel mogelijk te experimenteren. Zo kan je spelenderwijs leren en later, mocht je het interessant vinden, dieper in de theorie duiken. . Om het nog makkelijker te maken en sneller te kunnen beginnen met experimenteren heeft Fastai een eigen Python library (een term dat gebruikt wordt als: een uitbreiding van de programmeertaal Python). Met deze library, kun je met relatief weinig programmeerkennis een model trainen dat een voorspelling kan maken van, ja van wat niet eigenlijk. Dit kan zolang je maar genoeg voorbeelden (je data) hebt. Gelukkig hoef je niet altijd zelf je data te verzamelen, maar zijn er mensen die data gratis met de wereld delen. Tschandl et al. hebben plaatjes van moedervlekken bij elkaar gezocht en gelabeld (een label is de waarde die de data, in dit geval een foto, heeft). Specialisten op het gebied van moedervlekken hebben iedere foto beoordeeld als goed- of kwaadaardige moedervlek. Deze stap is erg belangrijk ,want zonder gelabelde data kun je eigenlijk geen AI model maken dat een nuttige voorspelling kan doen (met uitzondering van technieken die ongelabelde data gebruiken, maar dat is voor een volgende keer). En vaak geldt: des te meer data ,des te beter. . Nu we onze data hebben ,kunnen we bijna beginnen om een AI model te trainen. We hebben namelijk ook data nodig om ons model te evalueren. Hiervoor gebruik je data die niet is gebruikt tijdens het trainen. In de praktijk splits je daarom je data vaak in twee groepen. Een groep die je gebruikt om je model te trainen en een groep om te evalueren. Door deze splitsing evalueer je het getrainde model met data dat je model nog niet gezien heeft tijdens de training. Dat is erg belangrijk, want uiteindelijk wordt je model ook op deze manier gebruikt! Een foto die een gebruiker instuurt heeft het model nog nooit gezien en op deze foto&#39;s wil je een accurate voorspelling doen. . Ok, nu kunnen we dan echt beginnen met het trainen van het model. Voor foto&#39;s en plaatjes wordt (vaak) een speciale vorm model gebruikt, namelijk een convolutioneel neuraal netwerk (CNN; nog een term die ik later verder ga uitleggen, voor nu kan je een convolutie zien als een speciale rekensom). Zo &#39;n CNN gaan wij nu ook gebruiken (en de Fastai library maakt het ons erg gemakkelijk om dit te doen, maar de details bespreek ik weer later). . Tabel 1: Het trainen van een model. Epochs staat voor hoeveel keer je door je data heen gaat om je model te trainen. De train_loss is de loss die het model heeft op de trainingsdata en de valid_loss van je evaluatie data (hoe de loss wordt berekend ga ik later bespreken, de loss is berekend door het verschil tussen de voorspelde waarde door het model en de echte (gelabelde) waarde in een formule te stoppen). Als laatste bevat de tabel de tijd die 1 epoch duurt in minuten. . . In onderstaande tabel zie je dat we (na maar een paar minuten trainen) een accuuraatheid van maarliefst 95% hebben (Tabel 1; De error rate is lager dan 0.05, wat betekent dat de accuraatheid groter is dan (1 - 0.05) * 100%). Dat is de kracht van transfer learning en trainen op een grafische kaart (GPU). Een wezenlijk probleem is echter dat de accuraatheid verbonden is aan of je model een soortgelijke moedervlek heeft gezien tijdens de training. Hoewel we dat probleem zo goed mogelijk proberen op te lossen door je data te splitsen, is het nog steeds een probleem wanneer een moedervlek er compleet anders uit ziet, dan de moedervlekken waarop je het model hebt getraind. Dat is een reden waarom deze modellen in de praktijk nog geen specialisten vervangen en waarom je dus met een gek uitziende moedervlek altijd naar een specialist moet gaan. Maar deze modellen kunnen wel als hulpmiddel dienen voor deze specialisten! Dit voorbeeld laat dus de kracht, maar zeker ook een grote uitdaging van AI zien. . Er zijn veel voorbeelden waar soortgelijke technieken worden gebruikt (zie tabel 2). De code van dit project kan je vinden op Github en je kunt het getrainde model ook testen met een foto van een eigen moedervlek of eentje van het internet (moedervlek herkenner). . Tabel 2: Voorbeelden van andere projecten waarin biologische problemen worden opgelost met afbeeldingen. . soorten_scan = [&#39;MRI&#39;, &#39;H&amp;E gekleurde cellen&#39;, &#39;X-ray&#39;] functies = [&#39;Hersen Tumoren&#39;, &#39;Infiltrerende lymfocyten in tumoren&#39;, &#39;Borstkas aandoeningen&#39;] artikelen = [&#39;Ali Işın, Cem Direkoğlu, Melike Şah, Review of MRI-based Brain Tumor Image Segmentation Using Deep Learning Methods, Procedia Computer Science, Volume 102,2016,Pages 317-324,ISSN 1877-0509,https://doi.org/10.1016/j.procs.2016.09.407.&#39;, &#39;Spatial Organization and Molecular Correlation of Tumor-Infiltrating Lymphocytes Using Deep Learning on Pathology Images, Cell Reports, Volume 23, Issue 1, Pages 181-193.e7, ISSN 2211-1247, https://doi.org/10.1016/j.celrep.2018.03.086.&#39;, &#39;Han Liu, Lei Wang, Yandong Nan, Faguang Jin, Qi Wang, Jiantao Pu, SDFN: Segmentation-based deep fusion network for thoracic disease classification in chest X-ray images, Computerized Medical Imaging and Graphics, Volume 75, Pages 66-73, ISSN 0895-6111, https://doi.org/10.1016/j.compmedimag.2019.05.005.&#39;] data = np.array(list(zip(soorten_scan, functies, artikelen))) df = pd.DataFrame(data=data, columns=[&#39;Soort Scan&#39;, &#39;Functie&#39;, &#39;Artikel&#39;]) df.head() . . Soort Scan Functie Artikel . 0 MRI | Hersen Tumoren | Ali Işın, Cem Direkoğlu, Melike Şah, Review of MRI-based Brain Tumor Image Segmentation Using Deep Learning Methods, Procedia Computer Science, Volume 102,2016,Pages 317-324,ISSN 1877-0509,https://doi.org/10.1016/j.procs.2016.09.407. | . 1 H&amp;E gekleurde cellen | Infiltrerende lymfocyten in tumoren | Spatial Organization and Molecular Correlation of Tumor-Infiltrating Lymphocytes Using Deep Learning on Pathology Images, Cell Reports, Volume 23, Issue 1, Pages 181-193.e7, ISSN 2211-1247, https://doi.org/10.1016/j.celrep.2018.03.086. | . 2 X-ray | Borstkas aandoeningen | Han Liu, Lei Wang, Yandong Nan, Faguang Jin, Qi Wang, Jiantao Pu, SDFN: Segmentation-based deep fusion network for thoracic disease classification in chest X-ray images, Computerized Medical Imaging and Graphics, Volume 75, Pages 66-73, ISSN 0895-6111, https://doi.org/10.1016/j.compmedimag.2019.05.005. | . We zijn weer aan het einde gekomen en ik kan me goed voorstellen dat het duizelt van de moeilijke termen. Ik ga proberen om die termen in toekomstige berichten zo duidelijk mogelijk uit te leggen. Mochten er vragen of opmerkingen zijn, dan kunnen jullie die hieronder plaatsen! Bedankt voor het lezen en tot de volgende keer! (Smeer je goed in tegen de zon!!). . 1. Dit soort modellen zijn geen vervanging van een specialist. Wanneer je een rare (moeder)vlek hebt, raadpleeg altijd een dokter.↩ . 2. Fastai website↩ . 3. Tschandl, Philipp, 2018, The HAM10000 dataset, a large collection of multi-source dermatoscopic images of common pigmented skin lesions, https://doi.org/10.7910/DVN/DBW86T, Harvard Dataverse, V3↩ .",
            "url": "https://cabbagemees.nl/projecten/cnn/biologie/2021/06/19/Kwaadaardige-Moedervlekken.html",
            "relUrl": "/projecten/cnn/biologie/2021/06/19/Kwaadaardige-Moedervlekken.html",
            "date": " • Jun 19, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Welkom op CabbageMees!",
            "content": "Hoi, . Mijn naam is Mees en sommige zullen zeggen dat ik een rare vogel ben (een koolmees bijvoorbeeld). In 2020 heb ik mijn Life Science &amp; Technology diploma van de Universiteit Leiden behaald. Nu wil ik deze kennis over de biologie verbinden met een andere passie van mij, namelijk programmeren en meer specifiek Artificiële Intelligentie (AI). Via deze blog wil ik jullie graag op de hoogte houden van mijn bezigheden. . Maar eerst nog even terug naar waar het allemaal begon. Toen ik nog jonger en kleiner was dan nu, was het mijn droom om een middel te vinden tegen kanker. Dat was voor mij de reden om, na de middelbare school, Life Science &amp; Technology te gaan studeren. Tijdens de studie kwam ik tot de conclusie dat het laboratorium niks voor mij was en dat ik op deze manier nooit een medicijn zou uitvinden. Dit was een enorme teleurstelling, maar gelukkig kwam ik er snel achter dat je op veel meer manieren bij kan dragen aan het ontwikkelen van medicijnen. Zo ben ik in aanraking gekomen met AI. . De eerste kennismaking was tijdens het vak computationele medicijn ontwikkeling (gegeven door prof. dr. ir. Fraaije). Tijdens deze colleges bespraken wij bijvoorbeeld Quantitative Structure-Activity Relationship (QSAR), een machinaal leren (een vorm van AI) techniek om te voorspellen wat voor eigenschappen een molecuul heeft (zoals elektronegativiteit). Dit sprak erg tot mijn verbeelding. En zo begon het fantaseren over een computer programma wat alles weet van het menselijk lichaam en van een potentieel medicijn waardoor het belangrijke eigenschappen van medicijnen kan voorspellen. Zoals of het medicijn werkzaam is, of er bijwerkingen zijn, in welk weefsel het medicijn zich het meeste bevind. JA, dacht ik. Dit is fantastisch! Ik wil zo snel mogelijk AI onder de knie krijgen! . Nu, een aantal jaren verder, heb ik veel geleerd. Van programmeren in Python tot het maken van neurale netwerken (een vorm van AI) en ik ben daar nog steeds iedere dag met passie mee bezig. Ook maak ik eigen projecten, maar hoe de reis verder zal gaan is nog onzeker. Mede daarom wil ik jullie graag mee nemen op deze reis. Daarnaast is het uitleggen van de technieken en termen die je zelf geleerd hebt de ultieme manier om jezelf te toetsen en dus vergt het dat je het onderwerp tot in de puntjes begrijpt. Als laatste, en misschien ook het belangrijkste, hoop ik jullie lezers te helpen bij het begrijpen van de soms lastige concepten die bij AI horen. . De droom om medicijnen te ontwikkelen met AI is er nog steeds, maar mijn eerste doel is een van de beste AI beoefenaars van Nederland te worden. Tot zo ver de eerste blog post en tot de volgende keer! . Mees .",
            "url": "https://cabbagemees.nl/de%20reis/introductie/2021/05/26/Eerste-blog-post.html",
            "relUrl": "/de%20reis/introductie/2021/05/26/Eerste-blog-post.html",
            "date": " • May 26, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "Over Mij",
          "content": "Hoi, . Leuk dat je kijkt op deze blog van een rare vogel (een Koolmees bijvoorbeeld). Als je mijn introductie (nog) niet hebt gelezen, dan kan je die hier vinden. Er is alweer een tijdje over heen gevlogen (blijf een vogel), toch verwijs ik graag naar de vervolg plannen van de blog hier. . Dit blog gaat dus over twee passies Artificiele Intelligentie (AI) en biologie. Op dit moment is eerst het plan om een van de beste AI beoefenaars te worden van Nederland. Om dat vervolgens toe te passen in de Biologie met als droom: op een goedkopere manier medicijnen te ontwikkelen. Ik neem jullie mee op dit avontuur. . Omdat de focus op dit moment ligt bij de beste AI beoefenaar te worden zal de komende tijd vooral de focus liggen op de volgende zaken: . Programmeren (vooral Python) | AI-technieken | . Wanneer ik dit beter onder de knie heb, wil ik ook mijn focus wat meer verschuiven naar AI in de biologie! . Wat doe ik nu (07JUN22) . Werk: Consultant bij Navara . Project . Flutter App maken | . Boeken . Herman Hesse - SteppenWolf (Roman) | Gerald Jay Sussman en Hal Abelson - Structure and Interpretation of Computer Programs (Programmeren) | . Cursussen . Berkeley 61A | Flutter Course for Beginners | . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://cabbagemees.nl/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://cabbagemees.nl/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}